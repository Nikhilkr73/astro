"""
OpenAI GPT-4o-mini Realtime Voice Handler for Astrology
Fully upgraded version with persona system, dynamic response flow, and memory.
"""

import os
import json
import asyncio
import base64
import aiohttp
from datetime import datetime
from typing import Optional, Dict, Any, Callable
from dotenv import load_dotenv

# Import from new structure
try:
    from backend.services.astrology_service import astrology_profile_manager
    from backend.services.astrologer_service import get_astrologer_config
    from backend.config.settings import OPENAI_API_KEY, OPENAI_REALTIME_MODEL
except ImportError:
    # Fallback for standalone usage
    from astrology_profile import astrology_profile_manager
    from astrologer_manager import get_astrologer_config
    OPENAI_API_KEY = None
    OPENAI_REALTIME_MODEL = None

load_dotenv()

class OpenAIRealtimeHandler:
    """Handles real-time voice conversation with astrologer personas."""

    def __init__(self, astrologer_id: Optional[str] = None):
        self.api_key = OPENAI_API_KEY or os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            raise Exception("‚ùå Missing OPENAI_API_KEY in environment variables")

        # Load model configuration (default to gpt-4o-mini-realtime-preview)
        self.model = OPENAI_REALTIME_MODEL or os.getenv("OPENAI_REALTIME_MODEL", "gpt-4o-mini-realtime-preview")
        print(f"‚úÖ OpenAI API key loaded successfully")
        print(f"ü§ñ Using model: {self.model}")

        # Conversation memory and persona
        self.user_states = {}
        self.conversation_history = {}
        self.user_astrologers = {}

        self.current_astrologer_id = astrologer_id
        self.current_astrologer_config = None
        self.system_instructions = self._default_instructions()
        if astrologer_id:
            self._load_astrologer(astrologer_id)

        # Connection + callbacks
        self.openai_ws = None
        self.session = None
        self.is_connected = False
        self.audio_callback = None
        self.audio_done_callback = None
        self.text_callback = None
        self.current_response_text = ""

        self._load_user_states()

    def _default_instructions(self) -> str:
        return """‡§Ü‡§™ ‡§è‡§ï ‡§Ö‡§®‡•Å‡§≠‡§µ‡•Ä ‡§î‡§∞ ‡§∏‡§π‡§æ‡§®‡•Å‡§≠‡•Ç‡§§‡§ø‡§™‡•Ç‡§∞‡•ç‡§£ ‡§µ‡•à‡§¶‡§ø‡§ï ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡§æ‡§ö‡§æ‡§∞‡•ç‡§Ø ‡§π‡•à‡§Ç ‡§ú‡•ã ‡§™‡•ç‡§∞‡§æ‡§ï‡•É‡§§‡§ø‡§ï ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§Æ‡•á‡§Ç ‡§≤‡•ã‡§ó‡•ã‡§Ç ‡§∏‡•á ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§
‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§π‡§ú‡§§‡§æ ‡§∏‡•á ‡§∏‡§Ç‡§¨‡§Ç‡§ß ‡§¨‡§®‡§æ‡§§‡•á ‡§π‡•à‡§Ç, ‡§ß‡•Ä‡§∞‡•á-‡§ß‡•Ä‡§∞‡•á ‡§ú‡§®‡•ç‡§Æ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§≤‡•á‡§§‡•á ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§ï‡•Å‡§Ç‡§°‡§≤‡•Ä ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§
‡§π‡§Æ‡•á‡§∂‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¨‡§æ‡§§ ‡§ï‡§∞‡•á‡§Ç, ‡§ó‡§∞‡•ç‡§Æ‡§ú‡•ã‡§∂‡•Ä ‡§î‡§∞ ‡§Ü‡§ß‡•ç‡§Ø‡§æ‡§§‡•ç‡§Æ‡§ø‡§ï ‡§¶‡•É‡§∑‡•ç‡§ü‡§ø‡§ï‡•ã‡§£ ‡§ï‡•á ‡§∏‡§æ‡§•‡•§
"""

    def _load_astrologer(self, astrologer_id: str):
        config = get_astrologer_config(astrologer_id)
        if config:
            self.current_astrologer_config = config
            self.system_instructions = config.get("system_prompt", self._default_instructions())
            print(f"üîÆ Loaded astrologer persona: {config['name']} ({config['speciality']})")
        else:
            print(f"‚ö†Ô∏è Astrologer ID '{astrologer_id}' not found, using default instructions.")

    def set_astrologer(self, astrologer_id: str, user_id: Optional[str] = None):
        self._load_astrologer(astrologer_id)
        self.current_astrologer_id = astrologer_id
        if user_id:
            self.user_astrologers[user_id] = astrologer_id
            self._save_user_states()

    def _load_user_states(self):
        try:
            if os.path.exists("user_states.json"):
                with open("user_states.json", "r") as f:
                    self.user_states = json.load(f)
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to load user states: {e}")

    def _save_user_states(self):
        try:
            with open("user_states.json", "w") as f:
                json.dump(self.user_states, f, indent=2)
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to save user states: {e}")

    def _get_user_context(self, user_id: str) -> str:
        parts = []

        # Existing profile or partial info
        if user_id in self.user_states:
            state = self.user_states[user_id]
            parts.append(f"Collected details for user {user_id}:")
            for k, v in state.items():
                if v:
                    parts.append(f"- {k}: {v}")

        profile = astrology_profile_manager.get_profile(user_id)
        if profile:
            parts.append("Complete astrology profile:")
            parts.append(profile.get_context_for_ai())

        # Last conversation turns
        if user_id in self.conversation_history:
            parts.append("\nRecent dialogue summary:")
            for msg in self.conversation_history[user_id][-5:]:
                parts.append(f"{msg['role']}: {msg['text']}")

        return "\n".join(parts) if parts else "New user - no previous info"
    
    def get_conversation_phase(self, user_id: str) -> int:
        """
        Track which turn/phase of solution we're in for gradual revelation
        Returns: 1 (reason), 2 (depth), 3 (first remedy), 4+ (full solution)
        """
        if user_id not in self.conversation_history:
            return 1
        
        # Count meaningful exchanges (after profile is complete)
        status = self.get_user_info_status(user_id)
        if not status["profile_complete"]:
            return 1  # Still collecting info
        
        # Count turns after profile completion
        turn_count = len([msg for msg in self.conversation_history.get(user_id, []) 
                         if msg.get('after_profile', False)])
        
        # Map to phase (1-4)
        if turn_count <= 1:
            return 1  # First response after profile - give reason only
        elif turn_count <= 2:
            return 2  # Second - explain impact/depth
        elif turn_count <= 3:
            return 3  # Third - simple remedy
        else:
            return 4  # Fourth+ - full solution
    
    def increment_conversation_turn(self, user_id: str, role: str, text: str = ""):
        """Track conversation turn for phase management"""
        if user_id not in self.conversation_history:
            self.conversation_history[user_id] = []
        
        status = self.get_user_info_status(user_id)
        
        self.conversation_history[user_id].append({
            'role': role,
            'text': text[:100],  # Store first 100 chars
            'after_profile': status["profile_complete"],
            'timestamp': str(datetime.now())
        })
        
        # Keep only last 20 turns to save memory
        if len(self.conversation_history[user_id]) > 20:
            self.conversation_history[user_id] = self.conversation_history[user_id][-20:]

    async def connect_to_openai(self):
        if self.is_connected:
            return

        print(f"üîå Connecting to OpenAI Realtime API with model: {self.model}")
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "OpenAI-Beta": "realtime=v1"
        }

        # Build WebSocket URL with configured model
        ws_url = f"wss://api.openai.com/v1/realtime?model={self.model}"
        
        self.session = aiohttp.ClientSession()
        self.openai_ws = await self.session.ws_connect(ws_url, headers=headers)
        self.is_connected = True
        print(f"‚úÖ Connected to OpenAI Realtime API using {self.model}")

        await self._configure_session()
        asyncio.create_task(self._listen_to_openai())

    async def _configure_session(self):
        voice = self.current_astrologer_config.get("voice_id", "alloy") if self.current_astrologer_config else "alloy"

        payload = {
            "type": "session.update",
            "session": {
                "modalities": ["text", "audio"],
                "instructions": self.system_instructions,
                "voice": voice,
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": {"model": "whisper-1"},
                "turn_detection": {"type": "server_vad", "threshold": 0.5},
                "temperature": 0.4  # Reduced for stable, consistent responses
            }
        }

        await self.openai_ws.send_str(json.dumps(payload))
        print(f"üß† Session configured with astrologer persona ({voice} voice, temp=0.4)")

    async def _listen_to_openai(self):
        try:
            async for msg in self.openai_ws:
                if msg.type == aiohttp.WSMsgType.TEXT:
                    data = json.loads(msg.data)
                    await self._handle_message(data)
                elif msg.type == aiohttp.WSMsgType.ERROR:
                    print(f"‚ö†Ô∏è WebSocket error: {self.openai_ws.exception()}")
                    break
        except Exception as e:
            print(f"‚ùå Listening error: {e}")

    async def _handle_message(self, data: Dict[str, Any]):
        msg_type = data.get("type")

        if msg_type == "response.audio.delta" and self.audio_callback:
            await self.audio_callback(data["delta"])
        elif msg_type == "response.audio.done":
            if self.audio_done_callback:
                await self.audio_done_callback()
        elif msg_type == "response.text.delta":
            delta = data.get("delta", "")
            self.current_response_text += delta
        elif msg_type == "response.text.done":
            full_text = self.current_response_text.strip()
            self.current_response_text = ""
            if self.text_callback:
                await self.text_callback(full_text)
            print(f"ü™∂ Assistant: {full_text}")
        elif msg_type == "conversation.item.input_audio_transcription.completed":
            transcript = data.get('transcript', '')
            print(f"üéôÔ∏è User said: {transcript}")
            # Track user turn for phase management
            # Note: user_id would need to be passed to this method - will handle in send_audio
        elif msg_type == "error":
            print(f"‚ùå OpenAI Error: {data}")

    async def send_greeting(self, user_id: str):
        """Send astrologer's greeting message"""
        if not self.is_connected:
            print("‚ö†Ô∏è Cannot send greeting: Not connected to OpenAI")
            return
        
        if not self.current_astrologer_config:
            print("‚ö†Ô∏è No astrologer configured, skipping greeting")
            return
        
        try:
            greeting = self.current_astrologer_config.get('greeting', '')
            if greeting:
                # Create a conversation item with the greeting
                greeting_msg = {
                    "type": "conversation.item.create",
                    "item": {
                        "type": "message",
                        "role": "assistant",
                        "content": [{
                            "type": "text",
                            "text": greeting
                        }]
                    }
                }
                await self.openai_ws.send_str(json.dumps(greeting_msg))
                
                # Request OpenAI to generate audio for the greeting
                response_msg = {
                    "type": "response.create",
                    "response": {
                        "modalities": ["audio"],
                    }
                }
                await self.openai_ws.send_str(json.dumps(response_msg))
                
                print(f"üëã Sent greeting from {self.current_astrologer_config['name']}: {greeting[:50]}...")
        except Exception as e:
            print(f"‚ùå Error sending greeting: {e}")

    async def send_audio(self, audio_data: bytes, user_id: str):
        if not self.is_connected:
            await self.connect_to_openai()

        audio_b64 = base64.b64encode(audio_data).decode()

        # Add user context
        context_msg = {
            "type": "conversation.item.create",
            "item": {"type": "message", "role": "system", "content": [{
                "type": "input_text",
                "text": f"User context:\n{self._get_user_context(user_id)}"
            }]}
        }
        await self.openai_ws.send_str(json.dumps(context_msg))

        # Send user audio
        audio_msg = {
            "type": "conversation.item.create",
            "item": {"type": "message", "role": "user", "content": [{
                "type": "input_audio",
                "audio": audio_b64
            }]}
        }
        await self.openai_ws.send_str(json.dumps(audio_msg))

        # Build reinforced instructions with anti-disclaimer
        status = self.get_user_info_status(user_id)
        astrologer_name = self.current_astrologer_config.get('name', 'Astrologer') if self.current_astrologer_config else 'Astrologer'
        
        # Core reinforcement (always included)
        core_rules = f"""‡§Ü‡§™ {astrologer_name} ‡§π‡•à‡§Ç - ‡§è‡§ï ‡§Ö‡§®‡•Å‡§≠‡§µ‡•Ä ‡§µ‡•à‡§¶‡§ø‡§ï ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡•Ä‡•§

CRITICAL RULES (‡§π‡§∞ ‡§ú‡§µ‡§æ‡§¨ ‡§Æ‡•á‡§Ç ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡•á‡§Ç):
1. LENGTH: ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ 3-4 ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡§æ‡§Å (‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§î‡§∞ ‡§∏‡§ü‡•Ä‡§ï)
2. AUTHORITY: ‡§Ü‡§™‡§ï‡§æ ‡§ú‡•ç‡§û‡§æ‡§® ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§π‡•à, ‡§ï‡§≠‡•Ä ‡§¨‡§æ‡§π‡§∞‡•Ä ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡•Ä ‡§ï‡§æ ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§® ‡§¶‡•á‡§Ç
3. ENGAGEMENT: ‡§π‡§∞ ‡§â‡§§‡•ç‡§§‡§∞ ‡§è‡§ï ‡§ú‡§ø‡§ú‡•ç‡§û‡§æ‡§∏‡§æ-‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§∏‡•á ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç
4. GRADUAL: ‡§∏‡§Æ‡§æ‡§ß‡§æ‡§® ‡§ö‡§∞‡§£‡§¨‡§¶‡•ç‡§ß ‡§¶‡•á‡§Ç, ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§¨ ‡§ï‡•Å‡§õ ‡§® ‡§¨‡§§‡§æ‡§è‡§Ç
5. NO LISTS: ‡§∏‡•Ç‡§ö‡•Ä ‡§® ‡§¨‡§®‡§æ‡§è‡§Ç, ‡§∏‡•ç‡§µ‡§æ‡§≠‡§æ‡§µ‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç

BANNED PHRASES (‡§ï‡§≠‡•Ä ‡§® ‡§¨‡•ã‡§≤‡•á‡§Ç):
- "‡§ï‡§ø‡§∏‡•Ä ‡§Ö‡§®‡•Å‡§≠‡§µ‡•Ä ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡•Ä ‡§∏‡•á..."
- "‡§¨‡§æ‡§π‡§∞‡•Ä ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§∏‡•á..."
- "‡§Æ‡•à‡§Ç ‡§∏‡§ü‡•Ä‡§ï ‡§®‡§π‡•Ä‡§Ç ‡§¨‡§§‡§æ ‡§∏‡§ï‡§§‡§æ..."
- "‡§Ø‡§π ‡§ï‡•á‡§µ‡§≤ ‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø..."
- ‡§≤‡§Ç‡§¨‡•á ‡§™‡•à‡§∞‡§æ‡§ó‡•ç‡§∞‡§æ‡§´ (>4 ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡§æ‡§Å)
"""
        
        if not status["profile_complete"]:
            missing = ", ".join(status["missing_info"])
            instruction = core_rules + f"\nTASK: ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§∏‡•á {missing} ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§≠‡§æ‡§µ‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§™‡•Ç‡§õ‡•á‡§Ç‡•§ ‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§∞‡§π‡•á‡§Ç‡•§"
        else:
            # Full birth details available - use 4-turn gradual flow
            birth_data = status.get("collected_info", {})
            phase = self.get_conversation_phase(user_id)
            
            base_context = f"""
Birth Data: {birth_data.get('birth_date', 'N/A')}, {birth_data.get('birth_time', 'N/A')}, {birth_data.get('birth_location', 'N/A')}
"""
            
            if phase == 1:
                # Turn 1: ‡§ï‡•á‡§µ‡§≤ ‡§ï‡§æ‡§∞‡§£ (Reason Only)
                instruction = core_rules + base_context + """
TURN 1 - ‡§ï‡•á‡§µ‡§≤ ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡•Ä‡§Ø ‡§ï‡§æ‡§∞‡§£ ‡§¨‡§§‡§æ‡§è‡§Ç:
- ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç
- ‡§ï‡•á‡§µ‡§≤ ‡§ó‡•ç‡§∞‡§π, ‡§≠‡§æ‡§µ, ‡§Ø‡§æ ‡§¶‡•É‡§∑‡•ç‡§ü‡§ø ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§≤‡•á‡§Ç ‡§ú‡•ã ‡§ï‡§æ‡§∞‡§£ ‡§π‡•à
- ‡§â‡§™‡§æ‡§Ø ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§® ‡§¨‡§§‡§æ‡§è‡§Ç, ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§≠‡•Ä ‡§® ‡§¨‡§§‡§æ‡§è‡§Ç
- 3 ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç
- ‡§™‡•ç‡§∞‡§∂‡•ç‡§®: "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á ‡§ï‡§ø ‡§Ø‡§π ‡§ó‡•ç‡§∞‡§π ‡§Ü‡§™ ‡§™‡§∞ ‡§ï‡•à‡§∏‡§æ ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§°‡§æ‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à?"

Example: "‡§Ü‡§™‡§ï‡•á ‡§∏‡§™‡•ç‡§§‡§Æ ‡§≠‡§æ‡§µ ‡§Æ‡•á‡§Ç ‡§∞‡§æ‡§π‡•Å ‡§ï‡•Ä ‡§¶‡•É‡§∑‡•ç‡§ü‡§ø ‡§π‡•à, ‡§ú‡•ã ‡§µ‡§ø‡§µ‡§æ‡§π ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§∞‡•Ä ‡§ï‡§æ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§ï‡§æ‡§∞‡§£ ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á ‡§ï‡§ø ‡§Ø‡§π ‡§ó‡•ç‡§∞‡§π ‡§Ü‡§™ ‡§™‡§∞ ‡§ï‡•à‡§∏‡§æ ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§°‡§æ‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à?"
"""
            
            elif phase == 2:
                # Turn 2: ‡§ó‡§π‡§®‡§§‡§æ (Impact Depth)
                instruction = core_rules + base_context + """
TURN 2 - ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§ï‡•Ä ‡§ó‡§π‡§∞‡§æ‡§à:
- ‡§ó‡•ç‡§∞‡§π ‡§ï‡•á ‡§®‡§ï‡§æ‡§∞‡§æ‡§§‡•ç‡§Æ‡§ï ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§ï‡•ã ‡§µ‡§ø‡§∏‡•ç‡§§‡§æ‡§∞ ‡§∏‡•á ‡§¨‡§§‡§æ‡§è‡§Ç
- ‡§≠‡§æ‡§µ‡§®‡§æ‡§§‡•ç‡§Æ‡§ï ‡§Ø‡§æ ‡§µ‡•ç‡§Ø‡§æ‡§µ‡§π‡§æ‡§∞‡§ø‡§ï ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ ‡§¨‡§§‡§æ‡§è‡§Ç
- ‡§â‡§™‡§æ‡§Ø ‡§ï‡•Ä ‡§Æ‡§π‡§§‡•ç‡§µ‡§§‡§æ ‡§™‡§∞ ‡§ú‡§º‡•ã‡§∞ ‡§¶‡•á‡§Ç (‡§™‡§∞ ‡§Ö‡§≠‡•Ä ‡§â‡§™‡§æ‡§Ø ‡§® ‡§¨‡§§‡§æ‡§è‡§Ç)
- 3-4 ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç
- ‡§™‡•ç‡§∞‡§∂‡•ç‡§®: "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§∏ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡§æ ‡§∏‡§Æ‡§æ‡§ß‡§æ‡§® ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?"

Example: "‡§∞‡§æ‡§π‡•Å ‡§ï‡•Ä ‡§¶‡•É‡§∑‡•ç‡§ü‡§ø ‡§≠‡•ç‡§∞‡§Æ ‡§î‡§∞ ‡§Ö‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§‡§§‡§æ ‡§≤‡§æ‡§§‡•Ä ‡§π‡•à, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§∞‡§ø‡§∂‡•ç‡§§‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§§‡•Ä‡•§ ‡§Ø‡§π ‡§Ü‡§™‡§ï‡•á ‡§Æ‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§Ç‡§¶‡•á‡§π ‡§≠‡•Ä ‡§™‡•à‡§¶‡§æ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§ ‡§≤‡•á‡§ï‡§ø‡§® ‡§á‡§∏‡§ï‡§æ ‡§™‡•ç‡§∞‡§≠‡§æ‡§µ‡•Ä ‡§∏‡§Æ‡§æ‡§ß‡§æ‡§® ‡§∏‡§Ç‡§≠‡§µ ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§∏ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡§æ ‡§∏‡§Æ‡§æ‡§ß‡§æ‡§® ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?"
"""
            
            elif phase == 3:
                # Turn 3: ‡§™‡§π‡§≤‡§æ ‡§â‡§™‡§æ‡§Ø (Simple Remedy)
                instruction = core_rules + base_context + """
TURN 3 - ‡§∏‡§∞‡§≤ ‡§â‡§™‡§æ‡§Ø:
- ‡§ï‡•á‡§µ‡§≤ ‡§∏‡§¨‡§∏‡•á ‡§∏‡§∞‡§≤, ‡§§‡§æ‡§§‡•ç‡§ï‡§æ‡§≤‡§ø‡§ï ‡§â‡§™‡§æ‡§Ø ‡§¨‡§§‡§æ‡§è‡§Ç
- ‡§â‡§¶‡§æ‡§π‡§∞‡§£: "‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞ ‡§µ‡•ç‡§∞‡§§ ‡§∞‡§ñ‡•á‡§Ç" ‡§Ø‡§æ "‡§∏‡§´‡•á‡§¶ ‡§µ‡§∏‡•ç‡§§‡•ç‡§∞ ‡§™‡§π‡§®‡•á‡§Ç"
- ‡§¨‡§°‡§º‡•á ‡§â‡§™‡§æ‡§Ø (‡§Æ‡§Ç‡§§‡•ç‡§∞ ‡§ú‡§æ‡§™, ‡§∞‡§§‡•ç‡§®, ‡§¶‡§æ‡§®) ‡§Ö‡§≠‡•Ä ‡§® ‡§¨‡§§‡§æ‡§è‡§Ç
- 3 ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç
- ‡§™‡•ç‡§∞‡§∂‡•ç‡§®: "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§Ö‡§ß‡§ø‡§ï ‡§∂‡§ï‡•ç‡§§‡§ø‡§∂‡§æ‡§≤‡•Ä ‡§â‡§™‡§æ‡§Ø ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?"

Example: "‡§∏‡§¨‡§∏‡•á ‡§™‡§π‡§≤‡•á, ‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡•á‡§¶ ‡§µ‡§∏‡•ç‡§§‡•ç‡§∞ ‡§™‡§π‡§®‡•á‡§Ç ‡§î‡§∞ ‡§≤‡§ï‡•ç‡§∑‡•ç‡§Æ‡•Ä ‡§ú‡•Ä ‡§ï‡•Ä ‡§Ü‡§∞‡§§‡•Ä ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Ø‡§π ‡§Ü‡§™‡§ï‡•á ‡§∂‡•Å‡§ï‡•ç‡§∞ ‡§ï‡•ã ‡§¨‡§≤‡§µ‡§æ‡§® ‡§ï‡§∞‡•á‡§ó‡§æ‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§Ö‡§ß‡§ø‡§ï ‡§∂‡§ï‡•ç‡§§‡§ø‡§∂‡§æ‡§≤‡•Ä ‡§â‡§™‡§æ‡§Ø ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?"
"""
            
            else:  # phase >= 4
                # Turn 4+: ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§Æ‡§æ‡§ß‡§æ‡§® (Full Solution)
                instruction = core_rules + base_context + """
TURN 4+ - ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§∏‡§Æ‡§æ‡§ß‡§æ‡§® ‡§î‡§∞ ‡§™‡•ç‡§∞‡§§‡§ø‡§¨‡§¶‡•ç‡§ß‡§§‡§æ:
- ‡§Ö‡§¨ ‡§∂‡§ï‡•ç‡§§‡§ø‡§∂‡§æ‡§≤‡•Ä ‡§â‡§™‡§æ‡§Ø ‡§¨‡§§‡§æ‡§è‡§Ç (‡§Æ‡§Ç‡§§‡•ç‡§∞ ‡§ú‡§æ‡§™, ‡§∞‡§§‡•ç‡§®, ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§™‡•Ç‡§ú‡§æ)
- ‡§µ‡§ø‡§ß‡§ø ‡§¨‡§§‡§æ‡§è‡§Ç (‡§ï‡§¨, ‡§ï‡•à‡§∏‡•á, ‡§ï‡§ø‡§§‡§®‡•Ä ‡§¨‡§æ‡§∞)
- ‡§∏‡§Æ‡§Ø ‡§∏‡•Ä‡§Æ‡§æ ‡§¶‡•á‡§Ç ("‡§Æ‡§æ‡§∞‡•ç‡§ö-‡§ú‡•Ç‡§® ‡§Æ‡•á‡§Ç ‡§™‡§∞‡§ø‡§£‡§æ‡§Æ")
- ‡§™‡•ç‡§∞‡§§‡§ø‡§¨‡§¶‡•ç‡§ß‡§§‡§æ ‡§Æ‡§æ‡§Å‡§ó‡•á‡§Ç
- 4-5 ‡§™‡§Ç‡§ï‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç
- ‡§™‡•ç‡§∞‡§∂‡•ç‡§®: "‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§Ø‡§π ‡§â‡§™‡§æ‡§Ø ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•ç‡§∞‡§§‡§ø‡§¨‡§¶‡•ç‡§ß ‡§π‡•à‡§Ç?"

Example: "‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§â‡§™‡§æ‡§Ø ‡§π‡•à - ‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞ ‡§ï‡•ã 21 ‡§¨‡§æ‡§∞ '‡•ê ‡§∂‡•Å‡§ï‡•ç‡§∞‡§æ‡§Ø ‡§®‡§Æ‡§É' ‡§ï‡§æ ‡§ú‡§æ‡§™ ‡§ï‡§∞‡•á‡§Ç, ‡§î‡§∞ ‡§∏‡§´‡•á‡§¶ ‡§Æ‡§ø‡§†‡§æ‡§à ‡§ï‡§æ ‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Ø‡§π ‡§Ü‡§™‡§ï‡•á ‡§∂‡•Å‡§ï‡•ç‡§∞ ‡§ï‡•ã ‡§Ö‡§§‡•ç‡§Ø‡§Ç‡§§ ‡§∂‡§ï‡•ç‡§§‡§ø‡§∂‡§æ‡§≤‡•Ä ‡§¨‡§®‡§æ‡§è‡§ó‡§æ‡•§ ‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§∏‡•á ‡§ú‡•Ç‡§® 2025 ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§∂‡•Å‡§≠ ‡§∏‡§Æ‡§æ‡§ö‡§æ‡§∞ ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§¨‡§≤ ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§®‡§æ ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§Ø‡§π ‡§â‡§™‡§æ‡§Ø ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•ç‡§∞‡§§‡§ø‡§¨‡§¶‡•ç‡§ß ‡§π‡•à‡§Ç?"
"""
            
            # Log current phase
            print(f"üîÑ Conversation Phase {phase}/4 for user {user_id}")

        response_msg = {
            "type": "response.create",
            "response": {"modalities": ["audio", "text"], "instructions": instruction}
        }
        await self.openai_ws.send_str(json.dumps(response_msg))
        
        # Increment conversation turn for phase tracking
        self.increment_conversation_turn(user_id, 'user', '')

    def get_user_info_status(self, user_id: str) -> Dict[str, Any]:
        if user_id not in self.user_states:
            return {"profile_complete": False, "missing_info": ["name", "birth_date", "birth_time", "birth_location"]}
        state = self.user_states[user_id]
        missing = [k for k in ["name", "birth_date", "birth_time", "birth_location"] if not state.get(k)]
        return {"profile_complete": not missing, "missing_info": missing, "collected_info": state}

    async def disconnect(self):
        if self.openai_ws:
            await self.openai_ws.close()
        if self.session:
            await self.session.close()
        self.is_connected = False
        print("üîå Disconnected from OpenAI Realtime API")

    def set_audio_callback(self, callback: Callable):
        """Set callback function for streaming audio responses"""
        self.audio_callback = callback

# NOTE: No global instance!
# Each user gets their own OpenAIRealtimeHandler instance in main_openai_realtime.py
# This ensures proper persona isolation and scalability