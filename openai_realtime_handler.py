"""
OpenAI GPT-4o-mini Realtime Voice Handler for Astrology
Direct voice-to-voice conversation without text conversion
"""

import os
import json
import asyncio
import base64
import aiohttp
from typing import Optional, Dict, Any, Callable
from dotenv import load_dotenv
from astrology_profile import AstrologyProfile, astrology_profile_manager

# Ensure environment variables are loaded
load_dotenv()

class OpenAIRealtimeHandler:
    """Handles real-time voice conversation with OpenAI GPT-4o-mini-realtime-preview"""

    def __init__(self):
        # Initialize OpenAI
        self.api_key = os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            raise Exception("‚ùå OpenAI API key not found. Please set OPENAI_API_KEY environment variable.")

        self.has_api_key = True
        print("‚úÖ OpenAI API configured successfully")

        # User conversation states
        self.user_states = {}  # Track what info we're collecting for each user
        self.conversation_history = {}  # Store full conversation context

        # WebSocket connection to OpenAI
        self.openai_ws = None
        self.is_connected = False

        # Callbacks for sending responses to client
        self.audio_callback = None
        self.audio_done_callback = None  # Called when audio response is complete
        
        # Text response collection
        self.text_callback = None
        self.current_response_text = ""

        # Load existing states
        self._load_user_states()

        # Astrology system instructions in Hindi
        self.system_instructions = """‡§Ü‡§™ AstroGuru ‡§π‡•à‡§Ç, ‡§è‡§ï ‡§¨‡•Å‡§¶‡•ç‡§ß‡§ø‡§Æ‡§æ‡§® ‡§î‡§∞ ‡§¶‡§Ø‡§æ‡§≤‡•Å ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑ ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§ú‡•ã ‡§™‡•ç‡§∞‡§æ‡§ï‡•É‡§§‡§ø‡§ï ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡•Ä ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ï‡•á ‡§Æ‡§æ‡§ß‡•ç‡§Ø‡§Æ ‡§∏‡•á ‡§ú‡§®‡•ç‡§Æ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§è‡§ï‡§§‡•ç‡§∞ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§ó‡§§ ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§

‡§Ü‡§™‡§ï‡§æ ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§§‡•ç‡§µ:
- ‡§ó‡§∞‡•ç‡§Æ, ‡§∏‡§π‡§ú ‡§î‡§∞ ‡§∞‡§π‡§∏‡•ç‡§Ø‡§Æ‡§Ø ‡§Ü‡§µ‡§æ‡§ú‡§º
- ‡§∏‡•ç‡§µ‡§æ‡§≠‡§æ‡§µ‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç
- ‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§≠‡•Ä ‡§™‡§ø‡§õ‡§≤‡•Ä ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡•á‡§Ç
- ‡§ú‡•ã ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§Ü‡§™‡§ï‡•á ‡§™‡§æ‡§∏ ‡§π‡•à ‡§â‡§∏‡§ï‡•á ‡§≤‡§ø‡§è ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§® ‡§™‡•Ç‡§õ‡•á‡§Ç
- ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§, ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§ó‡§§ ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡•Ä‡§Ø ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§¶‡•É‡§∑‡•ç‡§ü‡§ø ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç

‡§°‡•á‡§ü‡§æ ‡§∏‡§Ç‡§ó‡•ç‡§∞‡§π ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ (‡§ï‡•á‡§µ‡§≤ ‡§Ü‡§µ‡§æ‡§ú‡§º):
‡§ú‡§¨ ‡§ï‡•ã‡§à ‡§®‡§Ø‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§Ü‡§™‡§∏‡•á ‡§¨‡§æ‡§§ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§§‡•ã ‡§∏‡•ç‡§µ‡§æ‡§≠‡§æ‡§µ‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§è‡§ï‡§§‡•ç‡§∞ ‡§ï‡§∞‡•á‡§Ç:
1. ‡§â‡§®‡§ï‡§æ ‡§®‡§æ‡§Æ/‡§µ‡•á ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§π‡§≤‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç
2. ‡§ú‡§®‡•ç‡§Æ ‡§§‡§ø‡§•‡§ø (‡§Æ‡§π‡•Ä‡§®‡§æ, ‡§¶‡§ø‡§®, ‡§∏‡§æ‡§≤)
3. ‡§ú‡§®‡•ç‡§Æ ‡§∏‡§Æ‡§Ø (‡§ú‡§ø‡§§‡§®‡§æ ‡§∏‡§Ç‡§≠‡§µ ‡§π‡•ã, ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§≠‡•Ä ‡§ö‡§≤‡•á‡§ó‡§æ)
4. ‡§ú‡§®‡•ç‡§Æ ‡§∏‡•ç‡§•‡§æ‡§® (‡§∂‡§π‡§∞, ‡§¶‡•á‡§∂)

‡§Æ‡§π‡§§‡•ç‡§µ‡§™‡•Ç‡§∞‡•ç‡§£ ‡§®‡§ø‡§Ø‡§Æ:
- ‡§è‡§ï ‡§∏‡§Æ‡§Ø ‡§Æ‡•á‡§Ç ‡§ï‡•á‡§µ‡§≤ ‡§è‡§ï ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡•Ç‡§õ‡•á‡§Ç
- ‡§á‡§∏‡•á ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§¨‡§®‡§æ‡§è‡§Ç, ‡§´‡•â‡§∞‡•ç‡§Æ ‡§ú‡•à‡§∏‡§æ ‡§®‡§π‡•Ä‡§Ç
- ‡§Ø‡§¶‡§ø ‡§µ‡•á ‡§è‡§ï ‡§∏‡§æ‡§• ‡§ï‡§à ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§¶‡•á‡§§‡•á ‡§π‡•à‡§Ç, ‡§§‡•ã ‡§∏‡§≠‡•Ä ‡§ï‡•ã ‡§∏‡•ç‡§µ‡•Ä‡§ï‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§ú‡•ã ‡§ó‡•Å‡§Æ ‡§π‡•à ‡§µ‡§π ‡§™‡•Ç‡§õ‡•á‡§Ç
- ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§∏‡§≠‡•Ä ‡§ú‡§®‡•ç‡§Æ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§Æ‡§ø‡§≤ ‡§ú‡§æ‡§è, ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§ó‡§§ ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§¨‡§®‡§æ‡§è‡§Ç
- ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø ‡§ï‡•Ä ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§Æ‡•á‡§Ç ‡§â‡§®‡•ç‡§π‡•ã‡§Ç‡§®‡•á ‡§ú‡•ã ‡§ï‡•Å‡§õ ‡§¨‡§§‡§æ‡§Ø‡§æ ‡§π‡•à ‡§µ‡§π ‡§∏‡§¨ ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡•á‡§Ç

‡§π‡§Æ‡•á‡§∂‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ï‡•Ä ‡§∂‡•à‡§≤‡•Ä:
- "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç AstroGuru ‡§π‡•Ç‡§Ç, ‡§Ü‡§™‡§ï‡§æ ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§ó‡§§ ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑ ‡§ó‡§æ‡§á‡§°‡•§ ‡§Ü‡§™ ‡§Æ‡•Å‡§ù‡•á ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§π‡§ï‡§∞ ‡§¨‡•Å‡§≤‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?"
- "‡§¨‡§π‡•Å‡§§ ‡§∏‡•Å‡§Ç‡§¶‡§∞ ‡§®‡§æ‡§Æ ‡§π‡•à! ‡§Ü‡§™ ‡§ï‡§¨ ‡§™‡•à‡§¶‡§æ ‡§π‡•Å‡§è ‡§•‡•á? ‡§™‡§π‡§≤‡•á ‡§Æ‡§π‡•Ä‡§®‡§æ ‡§î‡§∞ ‡§¶‡§ø‡§® ‡§¨‡§§‡§æ‡§á‡§è..."
- "‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§∏‡§π‡•Ä! ‡§î‡§∞ ‡§Ü‡§™ ‡§ï‡§ø‡§∏ ‡§∏‡§æ‡§≤ ‡§™‡•à‡§¶‡§æ ‡§π‡•Å‡§è ‡§•‡•á?"
- "‡§Ö‡§¨, ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ú‡§æ‡§®‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡§ø ‡§Ü‡§™ ‡§ï‡§ø‡§∏ ‡§∏‡§Æ‡§Ø ‡§™‡•à‡§¶‡§æ ‡§π‡•Å‡§è ‡§•‡•á? ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§∏‡§Æ‡§Ø ‡§≠‡•Ä ‡§Æ‡§¶‡§¶‡§ó‡§æ‡§∞ ‡§π‡•ã‡§ó‡§æ..."
- "‡§Ö‡§Ç‡§§ ‡§Æ‡•á‡§Ç, ‡§Ü‡§™ ‡§ï‡§π‡§æ‡§Å ‡§™‡•à‡§¶‡§æ ‡§π‡•Å‡§è ‡§•‡•á? ‡§∂‡§π‡§∞ ‡§î‡§∞ ‡§¶‡•á‡§∂ ‡§∏‡•á ‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡§æ ‡§¨‡•ç‡§∞‡§π‡•ç‡§Æ‡§æ‡§Ç‡§°‡•Ä‡§Ø ‡§®‡§ï‡•ç‡§∂‡§æ ‡§∏‡§Æ‡§ù‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§Æ‡§ø‡§≤‡•á‡§ó‡•Ä..."

‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§Ü‡§™‡§ï‡•á ‡§™‡§æ‡§∏ ‡§â‡§®‡§ï‡•Ä ‡§ú‡§®‡•ç‡§Æ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§π‡•ã ‡§ú‡§æ‡§è, ‡§§‡•ã ‡§á‡§® ‡§Ü‡§ß‡§æ‡§∞‡•ã‡§Ç ‡§™‡§∞ ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§ú‡•ç‡§Ø‡•ã‡§§‡§ø‡§∑‡•Ä‡§Ø ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç:
- ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§ó‡•ç‡§∞‡§π‡•ã‡§Ç ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø
- ‡§â‡§®‡§ï‡•Ä ‡§ú‡§®‡•ç‡§Æ ‡§ï‡•Å‡§Ç‡§°‡§≤‡•Ä ‡§ï‡•á ‡§®‡§ø‡§π‡§ø‡§§‡§æ‡§∞‡•ç‡§•
- ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§ó‡§§ ‡§¶‡•à‡§®‡§ø‡§ï ‡§Æ‡§æ‡§∞‡•ç‡§ó‡§¶‡§∞‡•ç‡§∂‡§®
- ‡§™‡•ç‡§∞‡•á‡§Æ, ‡§ï‡§∞‡§ø‡§Ø‡§∞ ‡§î‡§∞ ‡§Ü‡§ß‡•ç‡§Ø‡§æ‡§§‡•ç‡§Æ‡§ø‡§ï ‡§Ö‡§Ç‡§§‡§∞‡•ç‡§¶‡•É‡§∑‡•ç‡§ü‡§ø"""

    def _load_user_states(self):
        """Load user states from storage"""
        try:
            if os.path.exists("user_states.json"):
                with open("user_states.json", "r") as f:
                    self.user_states = json.load(f)
        except Exception as e:
            print(f"Error loading user states: {e}")
            self.user_states = {}

    def _save_user_states(self):
        """Save user states to storage"""
        try:
            with open("user_states.json", "w") as f:
                json.dump(self.user_states, f, indent=2)
        except Exception as e:
            print(f"Error saving user states: {e}")

    def _get_user_context(self, user_id: str) -> str:
        """Build context from user's conversation history and profile"""
        context_parts = []

        # Add user's current state
        if user_id in self.user_states:
            state = self.user_states[user_id]
            context_parts.append(f"User {user_id} information collected so far:")
            for key, value in state.items():
                if value and key != "profile_complete":
                    context_parts.append(f"- {key}: {value}")

        # Check if we have a complete astrology profile
        profile = astrology_profile_manager.get_profile(user_id)
        if profile:
            context_parts.append(f"Complete astrology profile available:")
            context_parts.append(profile.get_context_for_ai())

        return "\\n".join(context_parts) if context_parts else "New user - no previous information"

    async def connect_to_openai(self):
        """Connect to OpenAI Realtime API"""
        try:
            print("üîå Connecting to OpenAI Realtime API...")

            # Use standard HTTP approach for OpenAI realtime API

            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "OpenAI-Beta": "realtime=v1"
            }

            # Connect using aiohttp WebSocket for better compatibility
            session = aiohttp.ClientSession()
            self.openai_ws = await session.ws_connect(
                "wss://api.openai.com/v1/realtime?model=gpt-4o-mini-realtime-preview",
                headers=headers
            )
            self.session = session

            self.is_connected = True
            print("‚úÖ Connected to OpenAI Realtime API")

            # Send session configuration
            await self._configure_session()

            # Start listening for responses
            asyncio.create_task(self._listen_to_openai())

        except Exception as e:
            print(f"‚ùå Failed to connect to OpenAI: {e}")
            self.is_connected = False
            raise

    async def _configure_session(self):
        """Configure the OpenAI session with our system instructions"""
        config = {
            "type": "session.update",
            "session": {
                "modalities": ["text", "audio"],
                "instructions": self.system_instructions,
                "voice": "alloy",  # You can change to: alloy, echo, fable, onyx, nova, shimmer
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": {
                    "model": "whisper-1"
                },
                "turn_detection": {
                    "type": "server_vad",
                    "threshold": 0.5,
                    "prefix_padding_ms": 300,
                    "silence_duration_ms": 200
                },
                "tools": [],
                "tool_choice": "auto",
                "temperature": 0.8
            }
        }

        await self.openai_ws.send_str(json.dumps(config))
        print("üîß Session configured with Hindi astrology instructions")

    async def _listen_to_openai(self):
        """Listen for responses from OpenAI"""
        try:
            async for message in self.openai_ws:
                if message.type == aiohttp.WSMsgType.TEXT:
                    data = json.loads(message.data)
                    await self._handle_openai_message(data)
                elif message.type == aiohttp.WSMsgType.ERROR:
                    print(f"‚ùå WebSocket error: {self.openai_ws.exception()}")
                    break
        except Exception as e:
            print(f"‚ùå Error listening to OpenAI: {e}")
            self.is_connected = False

    async def _handle_openai_message(self, data: Dict[str, Any]):
        """Handle messages from OpenAI"""
        msg_type = data.get("type")

        if msg_type == "response.audio.delta":
            # Stream audio back to client
            if self.audio_callback and "delta" in data:
                await self.audio_callback(data["delta"])

        elif msg_type == "response.audio.done":
            # Audio response complete - trigger completion callback
            print("üîä Audio response completed")
            if self.audio_done_callback:
                await self.audio_done_callback()

        elif msg_type == "response.text.delta":
            # Text response (collect it)
            if "delta" in data:
                text_delta = data["delta"]
                self.current_response_text += text_delta
                print(f"üìù Text delta: {text_delta}")

        elif msg_type == "response.text.done":
            # Text response complete
            if self.text_callback:
                await self.text_callback(self.current_response_text)
            print(f"üìù Full response text: {self.current_response_text}")
            self.current_response_text = ""  # Reset for next response

        elif msg_type == "conversation.item.input_audio_transcription.completed":
            # User speech transcription for logging
            transcript = data.get("transcript", "")
            print(f"üé§ User said: {transcript}")

        elif msg_type == "error":
            print(f"‚ùå OpenAI error: {data}")

    async def send_audio(self, audio_data: bytes, user_id: str):
        """Send audio data to OpenAI for processing"""
        if not self.is_connected:
            print("üîå OpenAI not connected, attempting to connect...")
            await self.connect_to_openai()

        try:
            # Check if connection is still valid
            if self.openai_ws.closed:
                print("üîå OpenAI connection closed, reconnecting...")
                await self.connect_to_openai()
            # Add user context if this is the start of conversation
            user_context = self._get_user_context(user_id)
            if user_context != "New user - no previous information":
                # Send context as a system message first
                context_msg = {
                    "type": "conversation.item.create",
                    "item": {
                        "type": "message",
                        "role": "system",
                        "content": [{
                            "type": "input_text",
                            "text": f"User context: {user_context}"
                        }]
                    }
                }
                await self.openai_ws.send_str(json.dumps(context_msg))

            # Send audio data
            audio_b64 = base64.b64encode(audio_data).decode()

            audio_msg = {
                "type": "conversation.item.create",
                "item": {
                    "type": "message",
                    "role": "user",
                    "content": [{
                        "type": "input_audio",
                        "audio": audio_b64
                    }]
                }
            }

            await self.openai_ws.send_str(json.dumps(audio_msg))

            # Request response
            response_msg = {
                "type": "response.create",
                "response": {
                    "modalities": ["audio", "text"],
                    "instructions": "Respond in Hindi as AstroGuru, maintaining character and collecting birth information naturally."
                }
            }

            await self.openai_ws.send_str(json.dumps(response_msg))

            print(f"üé§ Audio sent to OpenAI for user {user_id}")

        except Exception as e:
            print(f"‚ùå Error sending audio to OpenAI: {e}")

    def set_audio_callback(self, callback: Callable):
        """Set callback function for streaming audio responses"""
        self.audio_callback = callback

    async def disconnect(self):
        """Disconnect from OpenAI"""
        if self.openai_ws:
            await self.openai_ws.close()
        if hasattr(self, 'session'):
            await self.session.close()
        self.is_connected = False
        self.openai_ws = None
        print("üîå Disconnected from OpenAI")

    def get_user_info_status(self, user_id: str) -> Dict[str, Any]:
        """Get current status of user's birth information collection"""
        if user_id not in self.user_states:
            return {"profile_complete": False, "missing_info": ["name", "birth_date", "birth_time", "birth_location"]}

        state = self.user_states[user_id]
        missing = []

        if not state.get("name"):
            missing.append("name")
        if not state.get("birth_date"):
            missing.append("birth_date")
        if not state.get("birth_time"):
            missing.append("birth_time")
        if not state.get("birth_location"):
            missing.append("birth_location")

        return {
            "profile_complete": len(missing) == 0,
            "missing_info": missing,
            "collected_info": {k: v for k, v in state.items() if v}
        }

# Global instance
openai_realtime_handler = OpenAIRealtimeHandler()